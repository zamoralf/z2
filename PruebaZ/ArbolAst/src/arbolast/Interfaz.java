/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package arbolast;

import java.io.Reader;
import java.io.StringReader;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java_cup.runtime.ComplexSymbolFactory;

/**
 *
 * @author
 */
public class Interfaz extends javax.swing.JFrame {

    private Map<String, Variable> tablaSimbolos;
    private Nodo instrucciones;
    private String salida;
    private String ambitoActual;
    private int contadorAmbito;

    public Interfaz() {
        initComponents();
        tablaSimbolos = new HashMap<>();
        ambitoActual = "-";
        contadorAmbito = 0;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated
    // Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextArea3 = new javax.swing.JTextArea();
        jLabel3 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jTextArea1.setText(
                "/*calculo de 0 + 1 + 2 + ... + n - 2 + n - 1 + n,\npara un entero n*/\nn = 5\nb = 1\ni = 0\nwhile b < n + 1\n    i = i + b\n    b = b + 1\nend\nputs concat(\"sum( n = \", n, \" ) = \", i)");
        jTextArea1.setToolTipText("");
        jScrollPane1.setViewportView(jTextArea1);

        jTextArea2.setEditable(false);
        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jScrollPane2.setViewportView(jTextArea2);

        jLabel1.setText("Codigo de entrada:");

        jLabel2.setText("Codigo de salida:");

        jButton1.setText("Compilar");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jTextArea3.setEditable(false);
        jTextArea3.setColumns(20);
        jTextArea3.setRows(5);
        jScrollPane3.setViewportView(jTextArea3);

        jLabel3.setText("Tabla Sintactica:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addComponent(jButton1)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 387,
                                                        javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addComponent(jLabel1)))
                                .addGap(30, 30, 30)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jLabel2)
                                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 482,
                                                javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 482,
                                                javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addComponent(jLabel3))
                                .addContainerGap(25, Short.MAX_VALUE)));
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addGap(28, 28, 28)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                        .addComponent(jLabel1)
                                        .addComponent(jLabel2))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 327,
                                                javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGroup(layout.createSequentialGroup()
                                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 136,
                                                        javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addGap(27, 27, 27)
                                                .addComponent(jLabel3)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 130,
                                                        javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jButton1)
                                .addContainerGap(49, Short.MAX_VALUE)));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jButton1ActionPerformed
        try {
            tablaSimbolos.clear();
            salida = "";
            ambitoActual = "-";
            contadorAmbito = 0;

            Reader reader = new StringReader(jTextArea1.getText());
            AnalisisLexico scanner = new AnalisisLexico(reader);
            ComplexSymbolFactory sf = new ComplexSymbolFactory();
            scanner.setSymbolFactory(sf);
            AnalisisSintactico parser = new AnalisisSintactico(scanner, sf);
            parser.parse();

            instrucciones = parser.instrucciones;
            ejecutar(instrucciones);

            jTextArea2.setText(salida);
            actualizarTablaSimbolos();
        } catch (Exception exception) {
            jTextArea2.setText("Error: " + exception.getMessage());
            exception.printStackTrace();
        }
    }

    /**
     * @param args the command line arguments
     */

    private void actualizarTablaSimbolos() {
        StringBuilder tabla = new StringBuilder();
        tabla.append("Nombre\tTipo\tÁmbito\tValor final\n");
        tabla.append("----------------------------------------\n");

        for (Variable var : tablaSimbolos.values()) {
            tabla.append(var.nombre).append("\t")
                    .append(var.tipo != null ? var.tipo : "-").append("\t")
                    .append(var.ambito != null ? var.ambito : "-").append("\t")
                    .append(var.valor != null ? var.valor.toString() : "").append("\n");
        }

        jTextArea3.setText(tabla.toString());
    }

    private String nuevoAmbito(String prefijo) {
        contadorAmbito++;
        return prefijo + contadorAmbito;
    }

    private void ejecutar(Nodo instrucciones) throws Exception {
        int i = 0;
        Nodo instruccion;
        while (i < instrucciones.hijos.size()) {
            instruccion = instrucciones.hijos.get(i);

            if (instruccion.valor.equals("declaracion") || instruccion.valor.equals("declaracion_con_valor")) {
                // Manejo de Dim variable Como tipo = valor
                Nodo listaVariables = instruccion.hijos.get(0);
                Nodo tipoNodo = instruccion.hijos.get(1);
                String tipo = tipoNodo.valor;

                for (Nodo varNodo : listaVariables.hijos) {
                    String id = varNodo.valor;
                    Object valor = null;

                    // Si hay valor inicial
                    if (instruccion.valor.equals("declaracion_con_valor") && instruccion.hijos.size() > 2) {
                        valor = evaluarExpresion(instruccion.hijos.get(2));
                        valor = convertirTipo(valor, tipo);
                    } else {
                        // Valores por defecto según tipo
                        switch (tipo) {
                            case "int":
                                valor = 0;
                                break;
                            case "double":
                                valor = 0.0;
                                break;
                            case "boolean":
                                valor = false;
                                break;
                            case "char":
                                valor = ' ';
                                break;
                            case "string":
                                valor = "";
                                break;
                        }
                    }

                    Variable var = new Variable();
                    var.nombre = id;
                    var.tipo = tipo;
                    var.ambito = ambitoActual;
                    var.valor = valor;
                    tablaSimbolos.put(id, var);
                }
            } else if (instruccion.valor.equals("asignacion")) {
                String id = instruccion.hijos.get(0).hijos.get(0).valor;
                Object val = evaluarExpresion(instruccion.hijos.get(1));
                Variable var = tablaSimbolos.get(id);

                if (var == null) {
                    var = new Variable();
                    var.nombre = id;
                    var.ambito = ambitoActual;
                    tablaSimbolos.put(id, var);
                }

                // Verificación de tipos
                if (var.tipo != null) {
                    val = convertirTipo(val, var.tipo);
                }
                var.valor = val;
            } else if (instruccion.valor.equals("for")) {
                String id = instruccion.hijos.get(0).hijos.get(0).valor;
                Object inicio = evaluarExpresion(instruccion.hijos.get(1));
                Object limite = evaluarExpresion(instruccion.hijos.get(2));
                Object paso = evaluarExpresion(instruccion.hijos.get(3));
            
                // Crear nuevo ámbito
                String ambitoAnterior = ambitoActual;
                ambitoActual = nuevoAmbito("para");
                
                // Asignar valor inicial
                Variable var = new Variable();
                var.nombre = id;
                var.tipo = "int"; // Asumimos que los índices son enteros
                var.ambito = ambitoActual;
                var.valor = convertirTipo(inicio, "int");
                tablaSimbolos.put(id, var);
            
                // Ejecutar el bucle
                while (comparar(var.valor, limite, "<=")) {
                    ejecutar(instruccion.hijos.get(4)); // Ejecutar el cuerpo
            
                    // Actualizar variable
                    Object nuevoValor = operacionAritmetica(
                            var.valor,
                            paso,
                            "+");
                    var.valor = nuevoValor;
                }
                
                // Restaurar ámbito
                ambitoActual = ambitoAnterior;
            } else if (instruccion.valor.equals("if") || instruccion.valor.equals("if-else")) {
                // Crear nuevo ámbito
                String ambitoAnterior = ambitoActual;
                ambitoActual = nuevoAmbito("si");

                if ((Boolean) evaluarExpresion(instruccion.hijos.get(0))) {
                    ejecutar(instruccion.hijos.get(1));
                } else if (instruccion.hijos.size() > 2) { // Bloque "No" existe
                    ambitoActual = nuevoAmbito("no");
                    ejecutar(instruccion.hijos.get(2));
                }

                // Restaurar ámbito
                ambitoActual = ambitoAnterior;
            } else if (instruccion.valor.equals("while")) { // Mientras...FinMientras
                // Crear nuevo ámbito
                String ambitoAnterior = ambitoActual;
                ambitoActual = nuevoAmbito("mientras");

                while ((Boolean) evaluarExpresion(instruccion.hijos.get(0))) {
                    ejecutar(instruccion.hijos.get(1));
                }

                // Restaurar ámbito
                ambitoActual = ambitoAnterior;
            } else if (instruccion.valor.equals("do-while")) { // Hacer...RepetirMientras
                // Crear nuevo ámbito
                String ambitoAnterior = ambitoActual;
                ambitoActual = nuevoAmbito("hacer");

                do {
                    ejecutar(instruccion.hijos.get(0));
                } while ((Boolean) evaluarExpresion(instruccion.hijos.get(1)));

                // Restaurar ámbito
                ambitoActual = ambitoAnterior;
            } else if (instruccion.valor.equals("switch")) { // Seleccionar...FinSeleccionar
                // Crear nuevo ámbito
                String ambitoAnterior = ambitoActual;
                ambitoActual = nuevoAmbito("seleccionar");

                Object valor = evaluarExpresion(instruccion.hijos.get(0));
                boolean casoEjecutado = false;

                // Procesar casos normales
                for (Nodo caso : instruccion.hijos.get(1).hijos) {
                    System.out.println("Tipo de caso: " + caso.valor);
                    
                    if (caso.valor.equals("caso")) {
                        Object valorCaso = evaluarExpresion(caso.hijos.get(0));
                        System.out.println("Comparando " + valor + " con " + valorCaso);
                        
                        if (Objects.equals(valor, valorCaso)) {
                            System.out.println("Caso coincide, ejecutando...");
                            ejecutar(caso.hijos.get(1));
                            casoEjecutado = true;
                            break;
                        }
                    } else if (caso.valor.equals("default")) {
                        if (!casoEjecutado) {
                            System.out.println("Ejecutando caso por defecto");
                            ejecutar(caso.hijos.get(0));
                        }
                        break;
                    }
                }
                
                // Restaurar ámbito
                ambitoActual = ambitoAnterior;
            } else if (instruccion.valor.equals("imprimir")) {
                Object valor = evaluarExpresion(instruccion.hijos.get(0));
                salida += (valor != null ? valor.toString() : "null") + "\n";
            } else if (instruccion.valor.equals("imprimir_concat")) {
                StringBuilder resultado = new StringBuilder();

                // Primera expresión
                resultado.append(evaluarExpresion(instruccion.hijos.get(0)));

                // Expresiones concatenadas
                for (Nodo expr : instruccion.hijos.get(1).hijos) {
                    resultado.append(evaluarExpresion(expr));
                }

                salida += resultado.toString() + "\n";
            }

            i++;
        }
    }

    public class Variable {
        public String nombre;
        public String tipo;
        public String ambito;
        public Object valor;
    }

    private boolean comparar(Object a, Object b, String operador) throws Exception {
        // Si ambos son números
        if (a instanceof Number && b instanceof Number) {
            double numA = ((Number) a).doubleValue();
            double numB = ((Number) b).doubleValue();

            switch (operador) {
                case "<":
                    return numA < numB;
                case ">":
                    return numA > numB;
                case "<=":
                    return numA <= numB;
                case ">=":
                    return numA >= numB;
                case "==":
                    return numA == numB;
                case "!=":
                    return numA != numB;
                default:
                    throw new Exception("Operador no válido: " + operador);
            }
        }

        // Para otros tipos, comparamos como strings
        String strA = convertirAString(a);
        String strB = convertirAString(b);

        switch (operador) {
            case "==":
                return strA.equals(strB);
            case "!=":
                return !strA.equals(strB);
            default:
                throw new Exception("Operador " + operador + " no soportado para strings");
        }
    }

    private Object operacionAritmetica(Object a, Object b, String operacion) throws Exception {
        // Convertir a números si es posible
        if (!(a instanceof Number) || !(b instanceof Number)) {
            throw new Exception("Operación aritmética aplicada a no números");
        }

        double numA = ((Number) a).doubleValue();
        double numB = ((Number) b).doubleValue();
        double resultado;

        switch (operacion) {
            case "+":
                resultado = numA + numB;
                break;
            case "-":
                resultado = numA - numB;
                break;
            case "*":
                resultado = numA * numB;
                break;
            case "/":
                if (numB == 0) {
                    throw new Exception("División por cero");
                }
                resultado = numA / numB;
                break;
            case "^":
                resultado = Math.pow(numA, numB);
                break;
            case "%":
                resultado = numA % numB;
                break;
            default:
                throw new Exception("Operador aritmético no válido: " + operacion);
        }

        // Devolver el resultado con el tipo más apropiado
        if (a instanceof Integer && b instanceof Integer
                && operacion.matches("[+\\-*%]")) { // Operaciones que mantienen enteros
            return (int) resultado;
        }

        // Para división o potencia siempre devolvemos double
        return resultado;
    }

    private Object convertirTipo(Object valor, String tipo) throws Exception {
        try {
            switch (tipo) {
                case "int":
                    if (valor instanceof Double) {
                        return ((Double) valor).intValue();
                    }
                    return Integer.parseInt(valor.toString());
                case "double":
                    return Double.parseDouble(valor.toString());
                case "boolean":
                    return Boolean.parseBoolean(valor.toString());
                case "char":
                    String s = valor.toString();
                    if (s.length() == 1) {
                        return s.charAt(0);
                    }
                    throw new Exception("Char debe ser un único caracter");
                case "string":
                    return valor.toString();
                default:
                    throw new Exception("Tipo no reconocido: " + tipo);
            }
        } catch (Exception e) {
            throw new Exception("Error de conversión de tipo: " + e.getMessage());
        }
    }

    private Object evaluarExpresion(Nodo nodo) throws Exception {
        if (nodo == null) {
            throw new Exception("Nodo nulo en evaluación");
        }

        // Caso especial para cadenas directas
        if (nodo.valor.equals("CADENA_DIRECTA")) {
            return nodo.hijos.get(0).valor;
        }
        Nodo aux = nodo.hijos.get(0);
        switch (nodo.valor) {
            case "valor":
                return obtenerValorPrimitivo(nodo.hijos.get(0));

            case "variable":
                Variable var = tablaSimbolos.get(nodo.hijos.get(0).valor);
                if (var == null) {
                    throw new Exception("Variable no declarada: " + nodo.hijos.get(0).valor);
                }
                return var.valor;

            case "concatenar":
                StringBuilder sb = new StringBuilder();
                for (Nodo hijo : nodo.hijos) {
                    sb.append(convertirAString(evaluarExpresion(hijo)));
                }
                return sb.toString();
            case "and": {
                Boolean primera = (Boolean) evaluarExpresion(nodo.hijos.get(0));
                Boolean segunda = (Boolean) evaluarExpresion(nodo.hijos.get(1));
                return primera == true && segunda == true;
            }
            case "or": {
                Boolean primera = (Boolean) evaluarExpresion(nodo.hijos.get(0));
                Boolean segunda = (Boolean) evaluarExpresion(nodo.hijos.get(1));
                return primera == true || segunda == true;
            }
            case "not":
                return !(Boolean) evaluarExpresion(nodo.hijos.get(0));
            case "==": {
                Object primera = evaluarExpresion(nodo.hijos.get(0));
                Object segunda = evaluarExpresion(nodo.hijos.get(1));
                if (primera instanceof Integer) {
                    return Objects.equals((Integer) primera, (Integer) segunda);
                } else if (primera instanceof String) {
                    return ((String) primera).equals((String) segunda);
                } else if (primera instanceof Boolean) {
                    return Objects.equals((Boolean) primera, (Boolean) segunda);
                } else {
                    throw new Exception("No se reconoce el nodo");
                }
            }
            case "<": {
                Object primera = evaluarExpresion(nodo.hijos.get(0));
                Object segunda = evaluarExpresion(nodo.hijos.get(1));
                if (primera instanceof Number && segunda instanceof Number) {
                    return ((Number) primera).doubleValue() < ((Number) segunda).doubleValue();
                } else {
                    throw new Exception("Operador < requiere operandos numéricos");
                }
            }
            case ">": {
                Object primera = evaluarExpresion(nodo.hijos.get(0));
                Object segunda = evaluarExpresion(nodo.hijos.get(1));
                if (primera instanceof Number && segunda instanceof Number) {
                    return ((Number) primera).doubleValue() > ((Number) segunda).doubleValue();
                } else {
                    throw new Exception("Operador > requiere operandos numéricos");
                }
            }
            case "*": {
                Object primera = evaluarExpresion(nodo.hijos.get(0));
                Object segunda = evaluarExpresion(nodo.hijos.get(1));
                if (primera instanceof Number && segunda instanceof Number) {
                    // Si ambos son enteros, devolver entero
                    if (primera instanceof Integer && segunda instanceof Integer) {
                        return ((Integer) primera) * ((Integer) segunda);
                    }
                    // Si alguno es double, devolver double
                    return ((Number) primera).doubleValue() * ((Number) segunda).doubleValue();
                } else {
                    throw new Exception("Operador + requiere operandos numéricos");
                }
            }
            case "+": {
                Object primera = evaluarExpresion(nodo.hijos.get(0));
                Object segunda = evaluarExpresion(nodo.hijos.get(1));
                if (primera instanceof Number && segunda instanceof Number) {
                    // Si ambos son enteros, devolver entero
                    if (primera instanceof Integer && segunda instanceof Integer) {
                        return ((Integer) primera) + ((Integer) segunda);
                    }
                    // Si alguno es double, devolver double
                    return ((Number) primera).doubleValue() + ((Number) segunda).doubleValue();
                } else {
                    throw new Exception("Operador + requiere operandos numéricos");
                }
            }
            case "-": {
                Object primera = evaluarExpresion(nodo.hijos.get(0));
                Object segunda = evaluarExpresion(nodo.hijos.get(1));
                if (primera instanceof Number && segunda instanceof Number) {
                    // Si ambos son enteros, devolver entero
                    if (primera instanceof Integer && segunda instanceof Integer) {
                        return ((Integer) primera) - ((Integer) segunda);
                    }
                    // Si alguno es double, devolver double
                    return ((Number) primera).doubleValue() - ((Number) segunda).doubleValue();
                } else {
                    throw new Exception("Operador - requiere operandos numéricos");
                }
            }
            case "&": // Concatenación
                return evaluarExpresion(nodo.hijos.get(0)).toString()
                        + evaluarExpresion(nodo.hijos.get(1)).toString();

            case "/": // División
                Object div1 = evaluarExpresion(nodo.hijos.get(0));
                Object div2 = evaluarExpresion(nodo.hijos.get(1));
                if (div1 instanceof Integer && div2 instanceof Integer) {
                    return (Integer) div1 / (Integer) div2;
                } else if (div1 instanceof Double || div2 instanceof Double) {
                    return Double.parseDouble(div1.toString())
                            / Double.parseDouble(div2.toString());
                }
                throw new Exception("Tipos incompatibles para división");

            case "^": // Potencia
                Object base = evaluarExpresion(nodo.hijos.get(0));
                Object exp = evaluarExpresion(nodo.hijos.get(1));
                return Math.pow(Double.parseDouble(base.toString()),
                        Double.parseDouble(exp.toString()));

            case "%": // Módulo
                Object mod1 = evaluarExpresion(nodo.hijos.get(0));
                Object mod2 = evaluarExpresion(nodo.hijos.get(1));
                if (mod1 instanceof Integer && mod2 instanceof Integer) {
                    return (Integer) mod1 % (Integer) mod2;
                }
                throw new Exception("Módulo solo aplicable a enteros");

            case "<=":
                Object le1 = evaluarExpresion(nodo.hijos.get(0));
                Object le2 = evaluarExpresion(nodo.hijos.get(1));
                if (le1 instanceof Number && le2 instanceof Number) {
                    return ((Number) le1).doubleValue() <= ((Number) le2).doubleValue();
                }
                throw new Exception("Tipos incompatibles para <=");

            case ">=":
                Object ge1 = evaluarExpresion(nodo.hijos.get(0));
                Object ge2 = evaluarExpresion(nodo.hijos.get(1));
                if (ge1 instanceof Number && ge2 instanceof Number) {
                    return ((Number) ge1).doubleValue() >= ((Number) ge2).doubleValue();
                }
                throw new Exception("Tipos incompatibles para >=");

            case "!=":
                return !evaluarExpresion(nodo.hijos.get(0)).equals(
                        evaluarExpresion(nodo.hijos.get(1)));

            // Manejo de tipos específicos
            case "double":
                return Double.parseDouble(nodo.hijos.get(0).valor);

            case "boolean":
                return Boolean.parseBoolean(nodo.hijos.get(0).valor);

            case "char":
                return nodo.hijos.get(0).valor.charAt(0);

            case "": {
                Object primera = evaluarExpresion(nodo.hijos.get(0));
                Object segunda = evaluarExpresion(nodo.hijos.get(1));
                if (primera instanceof Integer) {
                    return (Integer) primera ^ (Integer) segunda;
                } else {
                    throw new Exception("No se reconoce el nodo");
                }
            }
            default:
                throw new Exception("No se reconoce el nodo");

        }

    }

    private Object obtenerValorPrimitivo(Nodo nodo) throws Exception {
        switch (nodo.valor) {
            case "entero":
                return Integer.parseInt(nodo.hijos.get(0).valor);
            case "double":
                return Double.parseDouble(nodo.hijos.get(0).valor);
            case "decimal":
                return Double.parseDouble(nodo.hijos.get(0).valor);
            case "boolean":
                return Boolean.parseBoolean(nodo.hijos.get(0).valor);
            case "char":
                String s = nodo.hijos.get(0).valor;
                if (s.length() == 1) {
                    return s.charAt(0);
                }
                throw new Exception("Char debe tener exactamente un caracter");
            case "cadena":
                return nodo.hijos.get(0).valor;
            default:
                throw new Exception("Tipo no reconocido: " + nodo.valor);
        }
    }

    private String convertirAString(Object valor) {
        if (valor == null) {
            return "null";
        }
        return valor.toString();
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextArea jTextArea3;
    // End of variables declaration//GEN-END:variables
}
